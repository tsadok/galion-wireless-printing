#!/usr/bin/perl
# -*- cperl -*-

# This version is designed to handle <form enctype="multipart/form-data" ...

sub taint {use Taint::Util (); for(@_){Taint::Util::taint($_) if defined $_} return @_;}
sub getforminput {
  my ($num_bytes, $bytesread, $formdata, $name, $value, $boundary, $part, $parts, $partdebug, $partname);
  $parts = 0;
  my (%head, %val, $headers, $h, %disposition, $content_disposition, $t, %partdata, %content_type);
  my %input;
  $num_bytes=$ENV{'CONTENT_LENGTH'} || 0;
  if ($num_bytes > 0) {
    $bytesread = read (STDIN, $formdata, $num_bytes);
  } else {
    $formdata=$ENV{'QUERY_STRING'} || "";
  }
  #open LOG, '>', 'forminput.log'; binmode LOG; print LOG $formdata; close LOG;
  if (($ENV{'CONTENT_TYPE'} || '') =~ /multipart\/form-data(?:.*boundary=(.+?))?$/) {
	$boundary=$1; taint($boundary);
    if (not $boundary) {
      warn "Did not find boundary in environment variable CONTENT_TYPE.";
    }
    #open LOG, '>', 'forminput-aux.log'; print LOG "$boundary\n";
	foreach $part (grep { $_ } split /[-]*$boundary(?:\r?\n)?/, $formdata) {
      #print LOG "part: {{{$part}}}\n";
      taint($part);
	  if ($main::debug) {
		$parts++;
		$partdebug.="<li><pre>$part</pre></li>";
	  }
	  $partname="";

      ($headers, $value) = $part =~ /^(.*?)\r?\n\r?\n(.*?)\r?$/s;
      ($head{$parts}, $val{$parts}) = taint($headers, $value);
      #print LOG "part headers: {{{" . (defined $headers ? $headers : '') . "}}}\n";
      #print LOG "part value: {{{" . (defined $value ? $value : '') . "}}}\n";

      my $filename;
	  foreach $h (split (/\n/, ($headers || ''))) {
        if ($h =~ /Content-Disposition: ([^;]+); (.*?)$/) {
		  taint(($content_disposition, $t)=($1,$2));
		  foreach $_ (split /; /, $t) {
            if (/^name=(.*?)$/) {
              $partname=$1; $partname=~s/\"//g; taint($partname);
              $disposition{$partname}=$content_disposition;
            } elsif (/^filename=["]?(.*)["?]\r?\n?$/) {
              $filename = $1; # Anything with a filename gets treated specially, below.
            } elsif (/^([^=]+)=([^=]+?)$/) {
              my ($n, $v) = ($1, $2); taint($n, $v);
              $partdata{$partname}{$n}=$v;
            } elsif ($main::debug>2) {
			  $main::dribble .= "<li>[Unrecognised name/value pair on content disposition line] <code>$_</code></li>\n";
            }
          }
        } elsif ($h=~/^Content-Type: (.*?)$/) {
          my $ctpn = $1;
          $content_type{$partname}=taint($ctpn);
		} elsif ($main::debug>2) {
		  $main::dribble .= "<li>[Unrecognised header] <pre>$h</pre></li>\n";
		}
	  }
      if ($filename) {
        $input{$partname}=$filename;
        $input{$partname . "_file_contents"} = $value;
      } else {
        $input{$partname}=$value;
      }
	}
  } else {
	foreach (split /&/, $formdata) {
      # Reverse the encoding generated by the browser for the CGI interface:
	  s/\+/ /g; # Decode spaces
	  ($name, $value) = split(/=/, $_);
	  $name =~ s/%(..)/pack("c",hex($1))/ge;  # These lines reverse the %nn encodings
	  $value =~ s/%(..)/pack("c",hex($1))/ge; # cgi does for punctuation marks and such.
      taint($name, $value);
      if (exists $input{$name}) {
        $input{$name} .= ",$value";
        # Yes, this means that if you have multiple inputs with the
        # same name (e.g., checkboxen) you dursn't have commas within
        # any of the possible values.
      } else {
        $input{$name}=$value;
      }
	}
  }
  if ($main::formmagic) {
    $main::formmagic->(\%input);
    $formdata ||= 1;
  }
  if ($formdata) {
    return \%input;
  } else {
    return undef;
  }
}

1;
